#include "analyzer.h"
#include "bsp.h" // Board Support Package
#include "pc_com.h"
#include "private_signal_ranges.h"
#include "qpc.h" // QP/C real-time embedded framework
#include "safe_strncpy.h"
#include <math.h>
#include <stdio.h>
#include <string.h>

Q_DEFINE_THIS_MODULE("analyzer")

/**************************************************************************************************\
* Private macros
\**************************************************************************************************/

#define ADC_DOWNSAMPLING_RATE   5 // ADC clock runs 3x slower than DAC clock
#define ADC_DMA_BUFFER_MAX_SIZE 1024
#define DAC_DMA_BUFFER_MAX_SIZE ADC_DOWNSAMPLING_RATE *ADC_DMA_BUFFER_MAX_SIZE

#define NUM_ADC_SWEEPS 3

#define OUTPUT_MID   2050 // amplitude of sinusoid generated by DAC
#define OUTPUT_AMP   1950 // DC offset of sinusoid generated by DAC
#define pi           3.141592
#define SINUSOID_AMP 1024 // resolution of sin/cos for fourier transform

#define NUM_PERIODS 10 // (minimum) number of sinusoid waveforms to generate on DAC

// With 8 bit ADC, maximum reading is 0 to 256, to sinusoid amplitude is 128
#define MINIMUM_VOLTAGE_ACROSS_LOAD_RESISTOR 128 / 3
#define MAXIMUM_VOLTAGE_ACROSS_LOAD_RESISTOR 128 * 2 / 3

#define max(a, b)           \
    ({                      \
        typeof(a) _a = (a); \
        typeof(b) _b = (b); \
        _a > _b ? _a : _b;  \
    })

/**************************************************************************************************\
* Private type definitions
\**************************************************************************************************/

enum AnalyzerSignals
{
    SET_FREQ_RANGE_SIG = PRIVATE_SIGNAL_ANALYZER_START,
    BEGIN_FREQ_SWEEP_SIG,
    OFFSET_CALIBRATION_SIG,
    GAIN_CALIBRATION_SIG,
    SUBSTATE_FREQ_SWEEP_COMPLETE_SIG,
    TIMEOUT_SIG
};

typedef struct
{
    float32_t magnitude;
    float32_t phase;
    float32_t total_harmonic_distortion;
} MagPhase_T;

typedef struct
{
    QActive super; // inherit QActive

    // submachine state memory
    QStateHandler substate_super_state;

    QTimeEvt timeEvt; // private time event generator

    uint32_t freq_start;
    uint32_t freq_end;
    uint16_t num_freq_points;

    Source_Impedance_T source_impedance;

    uint32_t freq_list[FREQ_POINTS_MAX];
    uint16_t freq_index;

    uint16_t dac_dma_buffer[DAC_DMA_BUFFER_MAX_SIZE];
    int16_t sine_buffer[ADC_DMA_BUFFER_MAX_SIZE];
    int16_t cosine_buffer[ADC_DMA_BUFFER_MAX_SIZE];
    uint32_t adc_dma_buffer[ADC_DMA_BUFFER_MAX_SIZE];

    uint16_t dac_dma_data_len;
    uint16_t adc_dma_data_len;

    uint16_t sweep_number; // for labeling data on the python plot

    MagPhase_T voltage_measurements[FREQ_POINTS_MAX];
    MagPhase_T current_measurements[FREQ_POINTS_MAX];

    MagPhase_T current_offset_cal[FREQ_POINTS_MAX];
    MagPhase_T gain_offset_cal[FREQ_POINTS_MAX];
} Analyzer;

typedef struct
{
    QEvt super;

    uint32_t freq_start;
    uint32_t freq_end;
    uint32_t num_freq_points;
} SetFreqRangeEvent_T;

float32_t impedances[8] = {100, 330, 1000, 3300, 10000, 33000, 100000, 330000};

/**************************************************************************************************\
* Private prototypes
\**************************************************************************************************/

static QState initial(Analyzer *const me, void const *const par);
static QState top(Analyzer *const me, QEvt const *const e);
static QState standby(Analyzer *const me, QEvt const *const e);
static QState running(Analyzer *const me, QEvt const *const e);
static QState impedance_sweep(Analyzer *const me, QEvt const *const e);
static QState offset_calibration(Analyzer *const me, QEvt const *const e);
static QState gain_calibration(Analyzer *const me, QEvt const *const e);

static QState substate_impedance_sweep(Analyzer *const me, QEvt const *const e);

// Substate machine
static QState substate_do_frequency_sweep(QStateHandler super_state);

static uint32_t PeriodToFrequency(uint32_t period);
static void InitFrequenciesToSweep();
static void GenerateSinusoid(uint32_t frequency);
static MagPhase_T ADC_FourierAnalysis(int16_t *data, uint16_t data_len);
static void ApplyCurrentOffsetCalibration();
static void ApplyGainOffsetCalibration();

static void log_XY(uint8_t plot_number, const char *data_label, uint32_t x, float32_t y);
static void log_data(uint8_t plot_number, const char *data_label, float32_t data_point);
static void log_data_block(
    uint8_t plot_number,
    const char *data_label,
    uint32_t *data_x,
    float32_t *data_y,
    int16_t data_len);

/**************************************************************************************************\
* Private memory declarations
\**************************************************************************************************/

extern Analyzer Analyzer_inst; // the Blinky active object
Analyzer Analyzer_inst;
QActive *const AO_Analyzer = &Analyzer_inst.super;

/**************************************************************************************************\
* Public functions
\**************************************************************************************************/

void Analyzer_ctor(void)
{
    Analyzer *const me = &Analyzer_inst;
    QActive_ctor(&me->super, Q_STATE_CAST(&initial));
    QTimeEvt_ctorX(&me->timeEvt, &me->super, TIMEOUT_SIG, 0U);

    memset(me->adc_dma_buffer, 0, ADC_DMA_BUFFER_MAX_SIZE * sizeof(me->adc_dma_buffer[0]));
    memset(me->current_offset_cal, 0, FREQ_POINTS_MAX * sizeof(me->current_offset_cal[0]));

    me->freq_start      = 10000;
    me->freq_end        = 40000;
    me->num_freq_points = 100;

    me->source_impedance = IMPEDANCE_10k;
    BSP_Set_Source_Impedance(me->source_impedance);

    me->sweep_number = 0;

    // BSP_Set_DAC(OUTPUT_MID);

    InitFrequenciesToSweep();
}

void Analyzer_Set_Freq_Range(uint32_t freq_start, uint32_t freq_end, uint32_t num_freq_points)
{
    Analyzer *const me = &Analyzer_inst;

    SetFreqRangeEvent_T *event = Q_NEW(SetFreqRangeEvent_T, SET_FREQ_RANGE_SIG);

    event->freq_start      = freq_start;
    event->freq_end        = freq_end;
    event->num_freq_points = num_freq_points;

    QACTIVE_POST(&me->super, (QEvt *) (event), &me->super);
}

void Analyzer_Begin_Impedance_Sweep()
{
    Analyzer *const me      = &Analyzer_inst;
    static QEvt const event = QEVT_INITIALIZER(BEGIN_FREQ_SWEEP_SIG);
    QACTIVE_POST(&(me->super), &event, NULL);
}

void Analyzer_Begin_Offset_Calibration()
{
    Analyzer *const me      = &Analyzer_inst;
    static QEvt const event = QEVT_INITIALIZER(OFFSET_CALIBRATION_SIG);
    QACTIVE_POST(&(me->super), &event, NULL);
}

void Analyzer_Begin_Gain_Calibration()
{
    Analyzer *const me      = &Analyzer_inst;
    static QEvt const event = QEVT_INITIALIZER(GAIN_CALIBRATION_SIG);
    QACTIVE_POST(&(me->super), &event, NULL);
}

/**************************************************************************************************\
* Private functions
\**************************************************************************************************/

// HSM definition ----------------------------------------------------------
QState initial(Analyzer *const me, void const *const par)
{
    Q_UNUSED_PAR(par);

    QTimeEvt_armX(&me->timeEvt, BSP_TICKS_PER_SEC / 2U, BSP_TICKS_PER_SEC / 2U);

    // Initialize the DAC to the 'mid' level
    // me->dac_dma_buffer[0] = OUTPUT_MID;
    // BSP_Setup_ADC_DAC_DMA(
    //     me->adc1_dma_buffer, me->adc2_dma_buffer, me->adc_dma_data_len, me->dac_dma_buffer, 1,
    //     2);
    // BSP_Start_Waveform_Timer(10);

    return Q_TRAN(&top);
}
//............................................................................
QState top(Analyzer *const me, QEvt const *const e)
{
    QState status;
    switch (e->sig)
    {
        case Q_INIT_SIG: {
            status = Q_TRAN(&standby);
            break;
        }
        case Q_ENTRY_SIG: {
            status = Q_HANDLED();
            break;
        }
        case POSTED_SET_SOURCE_IMPEDANCE_SIG: {
            me->source_impedance = Q_EVT_CAST(SetSourceImpedanceEvent_T)->impedance;

            status = Q_HANDLED();
            break;
        }
        case POSTED_WAVEFORM_CAPTURE_COMPLETE_SIG: {
            status = Q_HANDLED();
            break;
        }
        default: {
            status = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status;
}
//............................................................................
QState standby(Analyzer *const me, QEvt const *const e)
{
    QState status;
    switch (e->sig)
    {
        case Q_ENTRY_SIG: {
            status = Q_HANDLED();
            break;
        }
        case SET_FREQ_RANGE_SIG: {
            const SetFreqRangeEvent_T *event = Q_EVT_CAST(SetFreqRangeEvent_T);
            Q_ASSERT(event->freq_start < event->freq_end);
            Q_ASSERT(event->freq_start >= FREQ_MIN);
            Q_ASSERT(event->freq_end <= FREQ_MAX);
            Q_ASSERT(event->num_freq_points >= FREQ_POINTS_MIN);
            Q_ASSERT(event->num_freq_points <= FREQ_POINTS_MAX);

            me->freq_start      = event->freq_start;
            me->freq_end        = event->freq_end;
            me->num_freq_points = event->num_freq_points;

            InitFrequenciesToSweep();

            status = Q_HANDLED();
            break;
        }
        // case TIMEOUT_SIG:
        case BEGIN_FREQ_SWEEP_SIG: {
            status = Q_TRAN(&impedance_sweep);
            break;
        }
        case OFFSET_CALIBRATION_SIG: {
            status = Q_TRAN(&offset_calibration);
            break;
        }
        case GAIN_CALIBRATION_SIG: {
            status = Q_TRAN(&gain_calibration);
            break;
        }
        default: {
            status = Q_SUPER(&top);
            break;
        }
    }
    return status;
}
//............................................................................
QState running(Analyzer *const me, QEvt const *const e)
{
    QState status;
    switch (e->sig)
    {
        case Q_ENTRY_SIG: {
            status = Q_HANDLED();
            break;
        }
        default: {
            status = Q_SUPER(&top);
            break;
        }
    }
    return status;
}
//............................................................................
QState impedance_sweep(Analyzer *const me, QEvt const *const e)
{
    QState status;
    switch (e->sig)
    {
        case Q_INIT_SIG: {
            status = substate_do_frequency_sweep((QStateHandler) &impedance_sweep);
            break;
        }
        case SUBSTATE_FREQ_SWEEP_COMPLETE_SIG: {
            ApplyCurrentOffsetCalibration();
            ApplyGainOffsetCalibration();

            MagPhase_T dut_impedance[FREQ_POINTS_MAX];

            for (int i = 0; i < me->num_freq_points; i++)
            {
                dut_impedance[i].magnitude = me->voltage_measurements[i].magnitude /
                    me->current_measurements[i].magnitude;
                dut_impedance[i].phase = me->voltage_measurements[i].phase -
                    me->current_measurements[i].phase;
            }

            // static float32_t dataV[512];
            // static float32_t dataI[512];
            static float32_t dataZmag[512];
            static float32_t dataZphase[512];
            for (int i = 0; i < me->num_freq_points; i++)
            {
                // dataV[i] = (float32_t) (me->voltage_measurements[i].magnitude);
                // dataI[i] = (float32_t) (me->current_measurements[i].magnitude);
                dataZmag[i]   = (float32_t) dut_impedance[i].magnitude;
                dataZphase[i] = (float32_t) dut_impedance[i].phase;
            }

            // log_data_block(0, "V", me->freq_list, dataV, me->num_freq_points);
            // log_data_block(1, "I", me->freq_list, dataI, me->num_freq_points);
            log_data_block(0, "Z mag", me->freq_list, dataZmag, me->num_freq_points);
            log_data_block(1, "Z phase", me->freq_list, dataZphase, me->num_freq_points);

            status = Q_TRAN(&standby);
            break;
        }
        default: {
            status = Q_SUPER(&running);
            break;
        }
    }
    return status;
}
//............................................................................
QState offset_calibration(Analyzer *const me, QEvt const *const e)
{
    QState status;
    switch (e->sig)
    {
        case Q_INIT_SIG: {
            status = substate_do_frequency_sweep((QStateHandler) &offset_calibration);
            break;
        }
        case SUBSTATE_FREQ_SWEEP_COMPLETE_SIG: {
            for (int i = 0; i < me->num_freq_points; i++)
            {
                me->current_offset_cal[i].magnitude = -me->current_measurements[i].magnitude;
                me->current_offset_cal[i].phase     = -me->current_measurements[i].phase;
            }

            PC_COM_print("Offset calibration complete");

            status = Q_TRAN(&standby);
            break;
        }

        default: {
            status = Q_SUPER(&running);
            break;
        }
    }
    return status;
}
//............................................................................
QState gain_calibration(Analyzer *const me, QEvt const *const e)
{
    QState status;
    switch (e->sig)
    {
        case Q_INIT_SIG: {
            status = substate_do_frequency_sweep((QStateHandler) &gain_calibration);
            break;
        }
        case SUBSTATE_FREQ_SWEEP_COMPLETE_SIG: {
            ApplyCurrentOffsetCalibration();

            for (int i = 0; i < me->num_freq_points; i++)
            {
                MagPhase_T thisImpedance;
                thisImpedance.magnitude = me->voltage_measurements[i].magnitude /
                    me->current_measurements[i].magnitude;
                thisImpedance.phase = me->voltage_measurements[i].phase -
                    me->current_measurements[i].phase;
                me->gain_offset_cal[i].magnitude = 10000.0 / thisImpedance.magnitude;
                me->gain_offset_cal[i].phase     = -thisImpedance.phase;
            }

            PC_COM_print("Gain calibration complete");

            status = Q_TRAN(&standby);
            break;
        }

        default: {
            status = Q_SUPER(&running);
            break;
        }
    }
    return status;
}
//............................................................................
QState substate_impedance_sweep(Analyzer *const me, QEvt const *const e)
{
    QState status;
    switch (e->sig)
    {
        case Q_ENTRY_SIG: {
            // char print_buffer[PC_COM_EVENT_MAX_MSG_LENGTH] = {0};
            // snprintf(print_buffer, sizeof(print_buffer), "%d Hz", me->freq_list[me->freq_index]);
            // PC_COM_print(print_buffer);

            BSP_Set_Source_Impedance(me->source_impedance);
            BSP_Stop_ADC_DAC_DMA();
            GenerateSinusoid(me->freq_list[me->freq_index]);
            // uint16_t dac_total_clock_periods = max(
            //     2 * me->adc_dma_data_len * ADC_DOWNSAMPLING_RATE,
            //     NUM_PERIODS * me->dac_dma_data_len);
            uint16_t dac_total_clock_periods = NUM_ADC_SWEEPS * me->adc_dma_data_len *
                ADC_DOWNSAMPLING_RATE;
            dac_total_clock_periods++;

            BSP_Setup_ADC_DAC_DMA(
                me->adc_dma_buffer,
                me->adc_dma_data_len,
                me->dac_dma_buffer,
                me->dac_dma_data_len,
                dac_total_clock_periods);
            BSP_Start_Waveform_Timer();

            status = Q_HANDLED();
            break;
        }
        case POSTED_WAVEFORM_CAPTURE_COMPLETE_SIG: {
            // Voltage across source impedance is ADC2-ADC1

            int16_t applied_voltage_waveform[ADC_DMA_BUFFER_MAX_SIZE];
            int16_t voltage_across_resistor_waveform[ADC_DMA_BUFFER_MAX_SIZE];
            for (int i = 0; i < me->adc_dma_data_len; i++)
            {
                int16_t v1 = me->adc_dma_buffer[i] & 0xFFF;
                int16_t v2 = me->adc_dma_buffer[i] >> 16;

                applied_voltage_waveform[i]         = v2;
                voltage_across_resistor_waveform[i] = v2 - v1;
            }
            MagPhase_T resistor_voltage = ADC_FourierAnalysis(
                voltage_across_resistor_waveform, me->adc_dma_data_len);

            MagPhase_T applied_voltage = ADC_FourierAnalysis(
                applied_voltage_waveform, me->adc_dma_data_len);

            // // if the source resistor voltage is too small, impedance should be increased
            // if (resistor_voltage.magnitude < MINIMUM_VOLTAGE_ACROSS_LOAD_RESISTOR &&
            //     me->source_impedance < IMPEDANCE_MAX)
            // {
            //     me->source_impedance++;
            //     status = Q_TRAN(&begin_sinusoid);
            // }
            // // if the source resistor voltage is too great, impedance should be decreased
            // else if (
            //     resistor_voltage.magnitude > MAXIMUM_VOLTAGE_ACROSS_LOAD_RESISTOR &&
            //     me->source_impedance > IMPEDANCE_MIN)
            // {
            //     me->source_impedance--;
            //     status = Q_TRAN(&begin_sinusoid);
            // }
            // else
            // {
            MagPhase_T current;
            current.magnitude = resistor_voltage.magnitude / impedances[me->source_impedance];
            current.phase     = resistor_voltage.phase;

            me->voltage_measurements[me->freq_index] = applied_voltage;
            me->current_measurements[me->freq_index] = current;

            // char mag_label[16] = {0};
            // snprintf(mag_label, sizeof(mag_label), "mag %d", me->sweep_number);
            // log_XY(1, mag_label, me->freq_list[me->freq_index], dut_impedance.magnitude);
            // char phase_label[16] = {0};
            // snprintf(phase_label, sizeof(phase_label), "phase %d", me->sweep_number);
            // log_XY(2, phase_label, me->freq_list[me->freq_index], dut_impedance.phase);

            // plot the raw data
            // static float32_t applied_data_float[512];
            // static float32_t delta_data_float[512];
            // for (int i = 0; i < me->adc_dma_data_len; i++)
            // {
            //     // adc1_data_float[i] = (float32_t) (me->adc_dma_buffer[i] & 0xFFF);
            //     // adc2_data_float[i] = (float32_t) (me->adc_dma_buffer[i] >> 16);
            //     applied_data_float[i] = (float32_t) (applied_voltage_waveform[i]);
            //     delta_data_float[i]   = (float32_t) (voltage_across_resistor_waveform[i]);
            // }

            // log_data_block(0, "delta", delta_data_float, me->adc_dma_data_len);
            // log_data_block(0, "applied", applied_data_float, me->adc_dma_data_len);

            me->freq_index++;
            if (me->freq_index == me->num_freq_points)
            {
                static QEvt const event = QEVT_INITIALIZER(SUBSTATE_FREQ_SWEEP_COMPLETE_SIG);
                QACTIVE_POST(&(me->super), &event, NULL);
                status = Q_HANDLED();
            }
            else
                status = Q_TRAN(&substate_impedance_sweep);
            // }
            break;
        }
        default: {
            status = Q_SUPER(me->substate_super_state);
            break;
        }
    }
    return status;
}

/**
 ***************************************************************************************************
 *
 * @brief   Substate machine
 *
 **************************************************************************************************/

static QState substate_do_frequency_sweep(QStateHandler super_state)
{
    Analyzer *const me       = &Analyzer_inst;
    me->freq_index           = 0; // start at the beginning of the sweep
    me->substate_super_state = super_state;
    return Q_TRAN(&substate_impedance_sweep);
}

/**
 ***************************************************************************************************
 *
 * @brief   Convert frequency [Hz] to number of timer periods at the ADC's clock frequency
 *
 **************************************************************************************************/

static uint32_t PeriodToFrequency(uint32_t period)
{
    return 12000000ul / period / ADC_DOWNSAMPLING_RATE;
}

/**
 ***************************************************************************************************
 *
 * @brief   Populate array freq_list with logarithmically spaced frequencies between the min and
 *max
 *
 **************************************************************************************************/
static void InitFrequenciesToSweep()
{
    Analyzer *const me     = &Analyzer_inst;
    double freq_separation = pow(me->freq_end / me->freq_start, 1.0 / me->num_freq_points);
    uint32_t lastPer       = 0xFFFFFF;
    // distribute frequency points logarithmically
    int i;
    for (i = 0; i < me->num_freq_points; i++)
    {
        uint32_t thisFreq = me->freq_start * pow(freq_separation, i);
        Q_ASSERT(thisFreq >= FREQ_MIN);
        Q_ASSERT(thisFreq <= FREQ_MAX);
        uint32_t thisPer = PeriodToFrequency(thisFreq);
        if (thisPer == lastPer)
            break;
        me->freq_list[i] = PeriodToFrequency(thisPer);

        lastPer = thisPer;
    }

    do
    {
        me->freq_list[i++] = PeriodToFrequency(--lastPer);
    } while (PeriodToFrequency(lastPer) < me->freq_end);

    me->num_freq_points = i;

    me->freq_index = 0; // start at the beginning
}

/**
 ***************************************************************************************************
 *
 * @brief   Generate sinusoids in RAM of the appropriate frequency
 *
 **************************************************************************************************/
static void GenerateSinusoid(uint32_t frequency)
{
    Analyzer *const me = &Analyzer_inst;

    uint32_t waveform_period = PeriodToFrequency(frequency);
    Q_ASSERT(waveform_period > 0);
    Q_ASSERT(waveform_period <= ADC_DMA_BUFFER_MAX_SIZE);

    // Calculate how many whole periods can fit in our buffer
    uint8_t num_periods = ADC_DMA_BUFFER_MAX_SIZE / waveform_period;

    me->adc_dma_data_len = waveform_period * num_periods;
    Q_ASSERT(me->adc_dma_data_len <= ADC_DMA_BUFFER_MAX_SIZE);
    me->dac_dma_data_len = waveform_period * ADC_DOWNSAMPLING_RATE;
    Q_ASSERT(me->dac_dma_data_len <= DAC_DMA_BUFFER_MAX_SIZE);

    for (uint16_t i = 0; i < me->dac_dma_data_len; i++)
    {
        double this_sin       = sin(2 * pi * i / waveform_period / ADC_DOWNSAMPLING_RATE);
        me->dac_dma_buffer[i] = OUTPUT_MID + this_sin * OUTPUT_AMP;

        if (i % ADC_DOWNSAMPLING_RATE == 0)
        {
            double this_cos = cos(2 * pi * i / waveform_period / ADC_DOWNSAMPLING_RATE);
            for (int j = 0; j < num_periods; j++)
            {
                me->sine_buffer[i / ADC_DOWNSAMPLING_RATE + j * waveform_period] = this_sin *
                    SINUSOID_AMP;
                me->cosine_buffer[i / ADC_DOWNSAMPLING_RATE + j * waveform_period] = this_cos *
                    SINUSOID_AMP;
            }
        }
    }
    // ensure that the final datapoint is exactly in the midpoint
    // me->dac_dma_buffer[0]                        = OUTPUT_MID;
    me->dac_dma_buffer[me->dac_dma_data_len - 1] = OUTPUT_MID;
    // me->dac_dma_buffer[me->dac_dma_data_len - 3] = OUTPUT_MID;
    // me->dac_dma_buffer[me->dac_dma_data_len - 2] = OUTPUT_MID;
    // me->dac_dma_buffer[1]                        = OUTPUT_MID;
}

/**
 ***************************************************************************************************
 *
 * @brief   Find the amplitude and phase at a specific frequency in a sample of data
 *
 **************************************************************************************************/

static MagPhase_T ADC_FourierAnalysis(int16_t *data, uint16_t data_len)
{
    Analyzer *const me = &Analyzer_inst;

    MagPhase_T result;

    int32_t mean = 0;
    for (int i = 0; i < data_len; i++)
    {
        mean += data[i];
    }
    mean /= data_len;
    int32_t inPhase_sum      = 0;
    int32_t quadrature_sum   = 0;
    uint32_t mean_square_sum = 0; // the square of RMS
    for (int i = 0; i < data_len; i++)
    {
        inPhase_sum += data[i] * me->sine_buffer[i];
        quadrature_sum += data[i] * me->cosine_buffer[i];
        mean_square_sum += (data[i] - mean) * (data[i] - mean);
    }
    float32_t inPhase                = (float32_t) inPhase_sum / SINUSOID_AMP / data_len * 2;
    float32_t quadrature             = (float32_t) quadrature_sum / SINUSOID_AMP / data_len * 2;
    float32_t mean_square            = (float32_t) mean_square_sum / data_len * 2;
    result.magnitude                 = sqrt(inPhase * inPhase + quadrature * quadrature);
    result.phase                     = atan2(quadrature, inPhase) * 180.0 / pi;
    result.total_harmonic_distortion = sqrt(mean_square - result.magnitude * result.magnitude) /
        result.magnitude;

    return result;

    // if (calibrating)
    // {
    //     amp_cal_list[curr_freq_index]   = 1024.0 / amplitude;
    //     phase_cal_list[curr_freq_index] = -angle;
    // }
    // else if (calibrated)
    // {
    //     amplitude *= amp_cal_list[curr_freq_index];
    //     angle += phase_cal_list[curr_freq_index];
    // }
}

static void ApplyCurrentOffsetCalibration()
{
    Analyzer *const me = &Analyzer_inst;
    for (int i = 0; i < me->num_freq_points; i++)
    {
        me->current_measurements[i].magnitude += me->current_offset_cal[i].magnitude;
        me->current_measurements[i].phase += me->current_offset_cal[i].phase;
    }
}

static void ApplyGainOffsetCalibration()
{
    Analyzer *const me = &Analyzer_inst;
    for (int i = 0; i < me->num_freq_points; i++)
    {
        me->current_measurements[i].magnitude /= me->gain_offset_cal[i].magnitude;
        me->current_measurements[i].phase -= me->gain_offset_cal[i].phase;
    }
}

static void log_XY(uint8_t plot_number, const char *data_label, uint32_t x, float32_t y)
{
    AddDataToPlotEvent_T *event = Q_NEW(AddDataToPlotEvent_T, PUBSUB_ADD_DATA_TO_PLOT_SIG);
    event->milliseconds         = x;
    event->plot_number          = plot_number;
    safe_strncpy(event->data_label, data_label, sizeof(event->data_label));
    event->data_point = y;

    QACTIVE_PUBLISH(&event->super, &me->super);
}

static void log_data(const uint8_t plot_number, const char *data_label, const float32_t data_point)
{
    AddDataToPlotEvent_T *event = Q_NEW(AddDataToPlotEvent_T, PUBSUB_ADD_DATA_TO_PLOT_SIG);
    event->milliseconds         = BSP_Get_Milliseconds_Tick();
    event->plot_number          = plot_number;
    safe_strncpy(event->data_label, data_label, sizeof(event->data_label));
    event->data_point = data_point;

    QACTIVE_PUBLISH(&event->super, &me->super);
}

static void log_data_block(
    uint8_t plot_number,
    const char *data_label,
    uint32_t *data_x,
    float32_t *data_y,
    int16_t data_len)
{
    DrawPlotEvent_T *event = Q_NEW(DrawPlotEvent_T, PUBSUB_DRAW_PLOT_SIG);
    event->plot_number     = plot_number;
    safe_strncpy(event->data_label, data_label, sizeof(event->data_label));
    event->data_x   = data_x; // pass the pointer
    event->data_y   = data_y; // pass the pointer
    event->data_len = data_len;

    QACTIVE_PUBLISH(&event->super, &me->super);
}