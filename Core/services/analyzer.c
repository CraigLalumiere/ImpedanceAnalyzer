#include "analyzer.h"
#include "bsp.h" // Board Support Package
#include "pc_com.h"
#include "private_signal_ranges.h"
#include "qpc.h" // QP/C real-time embedded framework
#include "safe_strncpy.h"
#include <math.h>
#include <string.h>

Q_DEFINE_THIS_MODULE("analyzer")

/**************************************************************************************************\
* Private macros
\**************************************************************************************************/

#define ADC_DOWNSAMPLING_RATE   3 // ADC clock runs 3x slower than DAC clock
#define ADC_DMA_BUFFER_MAX_SIZE 512
#define DAC_DMA_BUFFER_MAX_SIZE ADC_DOWNSAMPLING_RATE *ADC_DMA_BUFFER_MAX_SIZE

#define OUTPUT_MID   2079 // amplitude of sinusoid generated by DAC
#define OUTPUT_AMP   1900 // DC offset of sinusoid generated by DAC
#define pi           3.141592
#define SINUSOID_AMP 1024 // resolution of sin/cos for fourier transform

#define NUM_PERIODS 10 // (minimum) number of sinusoid waveforms to generate on DAC

#define max(a, b)           \
    ({                      \
        typeof(a) _a = (a); \
        typeof(b) _b = (b); \
        _a > _b ? _a : _b;  \
    })

/**************************************************************************************************\
* Private type definitions
\**************************************************************************************************/

enum AnalyzerSignals
{
    SET_FREQ_RANGE_SIG = PRIVATE_SIGNAL_ANALYZER_START,
    BEGIN_FREQ_SWEEP_SIG,
    TIMEOUT_SIG
};

typedef struct
{
    QActive super; // inherit QActive

    QTimeEvt timeEvt; // private time event generator

    uint32_t freq_start;
    uint32_t freq_end;
    uint16_t num_freq_points;

    uint32_t freq_list[FREQ_POINTS_MAX];
    uint16_t freq_index;

    uint16_t dac_dma_buffer[DAC_DMA_BUFFER_MAX_SIZE];
    int16_t sine_buffer[ADC_DMA_BUFFER_MAX_SIZE];
    int16_t cosine_buffer[ADC_DMA_BUFFER_MAX_SIZE];
    uint16_t adc_dma_buffer[ADC_DMA_BUFFER_MAX_SIZE];

    uint16_t adc_dma_data_len;
    uint16_t dac_dma_data_len;
} Analyzer;

typedef struct
{
    QEvt super;

    uint32_t freq_start;
    uint32_t freq_end;
    uint32_t num_freq_points;
} SetFreqRangeEvent_T;

/**************************************************************************************************\
* Private prototypes
\**************************************************************************************************/

static QState initial(Analyzer *const me, void const *const par);
static QState top(Analyzer *const me, QEvt const *const e);
static QState standby(Analyzer *const me, QEvt const *const e);
static QState running(Analyzer *const me, QEvt const *const e);
static QState begin_sinusoid(Analyzer *const me, QEvt const *const e);
static QState sinusoid_complete(Analyzer *const me, QEvt const *const e);

static uint32_t PeriodToFrequency(uint32_t period);
static void InitFrequenciesToSweep();
static void GenerateSinusoid(uint32_t frequency);

static void PrintData(uint16_t *data, uint16_t len);

static void log_data(uint8_t plot_number, const char *data_label, int32_t data_point);

/**************************************************************************************************\
* Private memory declarations
\**************************************************************************************************/

extern Analyzer Analyzer_inst; // the Blinky active object
Analyzer Analyzer_inst;
QActive *const AO_Analyzer = &Analyzer_inst.super;

/**************************************************************************************************\
* Public functions
\**************************************************************************************************/

void Analyzer_ctor(void)
{
    Analyzer *const me = &Analyzer_inst;
    QActive_ctor(&me->super, Q_STATE_CAST(&initial));
    QTimeEvt_ctorX(&me->timeEvt, &me->super, TIMEOUT_SIG, 0U);

    memset(me->adc_dma_buffer, 0, ADC_DMA_BUFFER_MAX_SIZE * sizeof(me->adc_dma_buffer[0]));

    me->freq_start      = 10000;
    me->freq_end        = 100000;
    me->num_freq_points = 100;

    BSP_Set_Source_Impedance(IMPEDANCE_100);

    InitFrequenciesToSweep();
}

void Analyzer_Set_Freq_Range(uint32_t freq_start, uint32_t freq_end, uint32_t num_freq_points)
{
    Analyzer *const me = &Analyzer_inst;

    SetFreqRangeEvent_T *event = Q_NEW(SetFreqRangeEvent_T, SET_FREQ_RANGE_SIG);

    event->freq_start      = freq_start;
    event->freq_end        = freq_end;
    event->num_freq_points = num_freq_points;

    QACTIVE_POST(&me->super, (QEvt *) (event), &me->super);
}

void Analyzer_Begin_Impedance_Sweep()
{
    Analyzer *const me      = &Analyzer_inst;
    static QEvt const event = QEVT_INITIALIZER(BEGIN_FREQ_SWEEP_SIG);
    QACTIVE_POST(me, &event, &me->super);
}

/**************************************************************************************************\
* Private functions
\**************************************************************************************************/

// HSM definition ----------------------------------------------------------
QState initial(Analyzer *const me, void const *const par)
{
    Q_UNUSED_PAR(par);

    QTimeEvt_armX(&me->timeEvt, BSP_TICKS_PER_SEC / 10U, BSP_TICKS_PER_SEC / 10U);

    return Q_TRAN(&top);
}
//............................................................................
QState top(Analyzer *const me, QEvt const *const e)
{
    QState status;
    switch (e->sig)
    {
        case Q_INIT_SIG: {
            status = Q_TRAN(&standby);
            break;
        }
        case Q_ENTRY_SIG: {
            status = Q_HANDLED();
            break;
        }
        default: {
            status = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status;
}
//............................................................................
QState standby(Analyzer *const me, QEvt const *const e)
{
    QState status;
    switch (e->sig)
    {
        case Q_ENTRY_SIG: {
            status = Q_HANDLED();
            break;
        }
        case SET_FREQ_RANGE_SIG: {
            const SetFreqRangeEvent_T *event = Q_EVT_CAST(SetFreqRangeEvent_T);
            Q_ASSERT(event->freq_start < event->freq_end);
            Q_ASSERT(event->freq_start < FREQ_MIN);
            Q_ASSERT(event->freq_end < FREQ_MAX);
            Q_ASSERT(event->num_freq_points > FREQ_POINTS_MIN);
            Q_ASSERT(event->num_freq_points < FREQ_POINTS_MAX);

            me->freq_start      = event->freq_start;
            me->freq_end        = event->freq_end;
            me->num_freq_points = event->num_freq_points;

            InitFrequenciesToSweep();

            status = Q_HANDLED();
            break;
        }
        case TIMEOUT_SIG:
        case BEGIN_FREQ_SWEEP_SIG: {
            status = Q_TRAN(&running);
            break;
        }
        default: {
            status = Q_SUPER(&top);
            break;
        }
    }
    return status;
}
//............................................................................
QState running(Analyzer *const me, QEvt const *const e)
{
    QState status;
    switch (e->sig)
    {
        case Q_INIT_SIG: {
            status = Q_TRAN(&begin_sinusoid);
            break;
        }
        case Q_ENTRY_SIG: {
            me->freq_index = 0; // start at the beginning of the sweep
            status         = Q_HANDLED();
            break;
        }
        case Q_EXIT_SIG: {
            status = Q_HANDLED();
            break;
        }
        default: {
            status = Q_SUPER(&top);
            break;
        }
    }
    return status;
}
//............................................................................
QState begin_sinusoid(Analyzer *const me, QEvt const *const e)
{
    QState status;
    switch (e->sig)
    {
        case Q_ENTRY_SIG: {
            BSP_Stop_ADC_DAC_DMA();
            GenerateSinusoid(me->freq_list[me->freq_index]);
            uint16_t dac_total_clock_periods = max(
                2 * me->adc_dma_data_len * ADC_DOWNSAMPLING_RATE,
                NUM_PERIODS * me->dac_dma_data_len);
            BSP_Setup_ADC_DAC_DMA(
                me->adc_dma_buffer,
                me->adc_dma_data_len,
                me->dac_dma_buffer,
                me->dac_dma_data_len,
                dac_total_clock_periods);
            BSP_Start_Waveform_Timer();

            // PrintData(me->dac_dma_buffer, me->dac_dma_data_len);

            log_data(0, "label", 2);

            status = Q_HANDLED();
            break;
        }
        case POSTED_WAVEFORM_CAPTURE_COMPLETE_SIG: {
            status = Q_TRAN(&standby);
            // status = Q_TRAN(&sinusoid_complete);
            break;
        }
        default: {
            status = Q_SUPER(&running);
            break;
        }
    }
    return status;
}
//............................................................................
QState sinusoid_complete(Analyzer *const me, QEvt const *const e)
{
    QState status;
    switch (e->sig)
    {
        case Q_ENTRY_SIG: {
            status = Q_HANDLED();
            break;
        }
        default: {
            status = Q_SUPER(&running);
            break;
        }
    }
    return status;
}

/**
 ***************************************************************************************************
 *
 * @brief   Convert frequency [Hz] to number of timer periods at the ADC's clock frequency
 *
 **************************************************************************************************/

static uint32_t PeriodToFrequency(uint32_t period)
{
    return 15272727ul / period / ADC_DOWNSAMPLING_RATE;
}

/**
 ***************************************************************************************************
 *
 * @brief   Populate array freq_list with logarithmically spaced frequencies between the min and max
 *
 **************************************************************************************************/
static void InitFrequenciesToSweep()
{
    Analyzer *const me     = &Analyzer_inst;
    double freq_separation = pow(me->freq_end / me->freq_start, 1.0 / me->num_freq_points);
    for (int i = 0; i < me->num_freq_points; i++)
    {
        uint32_t thisFreq = me->freq_start * pow(freq_separation, i);
        Q_ASSERT(thisFreq >= FREQ_MIN);
        Q_ASSERT(thisFreq <= FREQ_MAX);
        me->freq_list[i] = thisFreq;
    }
}

/**
 ***************************************************************************************************
 *
 * @brief   Generate sinusoids in RAM of the appropriate frequency
 *
 **************************************************************************************************/
static void GenerateSinusoid(uint32_t frequency)
{
    Analyzer *const me = &Analyzer_inst;

    uint32_t waveform_period = PeriodToFrequency(frequency);
    Q_ASSERT(waveform_period > 0);
    Q_ASSERT(waveform_period <= ADC_DMA_BUFFER_MAX_SIZE);

    // Calculate how many whole periods can fit in our buffer
    uint8_t num_periods = ADC_DMA_BUFFER_MAX_SIZE / waveform_period;

    me->adc_dma_data_len = waveform_period * num_periods;
    Q_ASSERT(me->adc_dma_data_len <= ADC_DMA_BUFFER_MAX_SIZE);
    me->dac_dma_data_len = waveform_period * ADC_DOWNSAMPLING_RATE;
    Q_ASSERT(me->dac_dma_data_len <= DAC_DMA_BUFFER_MAX_SIZE);

    for (uint16_t i = 0; i < me->dac_dma_data_len; i++)
    {
        double this_sin       = sin(2 * pi * i / waveform_period / ADC_DOWNSAMPLING_RATE);
        me->dac_dma_buffer[i] = OUTPUT_MID + this_sin * OUTPUT_AMP;

        if (i % ADC_DOWNSAMPLING_RATE == 0)
        {
            double this_cos = cos(2 * pi * i / waveform_period / ADC_DOWNSAMPLING_RATE);
            for (int j = 0; j < num_periods; j++)
            {
                me->sine_buffer[i / ADC_DOWNSAMPLING_RATE + j * waveform_period] = this_sin *
                    SINUSOID_AMP;
                me->cosine_buffer[i / ADC_DOWNSAMPLING_RATE + j * waveform_period] = this_cos *
                    SINUSOID_AMP;
            }
        }
    }
    // ensure that the final datapoint is exactly in the midpoint
    me->dac_dma_buffer[me->dac_dma_data_len - 1] = OUTPUT_MID;
}

static void PrintData(uint16_t *data, uint16_t len)
{
    AppCLI_PostPrintf("\r\nData:");
    for (int i = 0; i < 1; i++)
    {
        AppCLI_PostPrintf("%d", data[i]);
    }
}

static void log_data(const uint8_t plot_number, const char *data_label, const int32_t data_point)
{
    AddDataToPlotEvent_T *event = Q_NEW(AddDataToPlotEvent_T, PUBSUB_ADD_DATA_TO_PLOT_SIG);
    event->milliseconds         = BSP_Get_Milliseconds_Tick();
    event->plot_number          = plot_number;
    safe_strncpy(event->data_label, data_label, sizeof(event->data_label));
    event->data_point = data_point;

    QACTIVE_PUBLISH(&event->super, &me->super);
}